---
title: "Chovanec et al. Nature protocols"
output: html_notebook
---

#### Load data

```{r}
library(readr)
library(biomaRt)
library(ggplot2)
library(reshape2)
library(ggthemes)


filenames_dna <- list.files("/media/chovanec/My_Passport/protocol_paper", 
                            pattern="*assembled_clones.tab", full.names=TRUE)

for(f in seq_along(filenames_dna)){
  assign(strsplit(basename(filenames_dna[f]), "_L00")[[1]][1], 
         suppressWarnings(suppressMessages(read_delim(filenames_dna[f], "\t", 
                                                      escape_double = FALSE, 
                                                      trim_ws = TRUE, 
                                                      progress = FALSE))))
}

all_dfs <- sapply(strsplit(basename(filenames_dna), "_L00"), "[[", 1)


filter_score <- function(df){
  #should not need to run this with latest Babrahamlinkon commit
  df_n <- df[df$V_SCORE >= 100,]
  df_n <- df_n[!is.na(df_n$X1),]
  #New column with true V_call and V_score
  df_n$V_CALL_first <- sapply(strsplit(df_n$V_CALL, ","), "[[", 1)
  df_n$V_CALL_gene <- sapply(strsplit(df_n$V_CALL_first, "\\*"), "[[", 1)
  df_n$J_CALL_first <- sapply(strsplit(df_n$J_CALL, ","), "[[", 1)
  df_n$J_CALL_gene <- sapply(strsplit(df_n$J_CALL_first, "\\*"), "[[", 1)
  df_n$J_gene <- sapply(strsplit(df_n$SEQUENCE_ID, "_"), "[[", 2)
  return(df_n)
}

#filter data for low v gene scores
for(i in seq_along(all_dfs)){
  assign(all_dfs[i], filter_score(get(all_dfs[i])))
}


```



Stat_smooth function from: 
http://stackoverflow.com/questions/7549694/adding-regression-line-equation-and-r2-on-graph
https://gist.github.com/kdauria/524eade46135f6348140

```{r}

stat_smooth_func <- function(mapping = NULL, data = NULL,
                             geom = "smooth", position = "identity",
                             ...,
                             method = "auto",
                             formula = y ~ x,
                             se = TRUE,
                             n = 80,
                             span = 0.75,
                             fullrange = FALSE,
                             level = 0.95,
                             method.args = list(),
                             na.rm = FALSE,
                             show.legend = NA,
                             inherit.aes = TRUE,
                             xpos = NULL,
                             ypos = NULL) {
  layer(
    data = data,
    mapping = mapping,
    stat = StatSmoothFunc,
    geom = geom,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      method = method,
      formula = formula,
      se = se,
      n = n,
      fullrange = fullrange,
      level = level,
      na.rm = na.rm,
      method.args = method.args,
      span = span,
      xpos = xpos,
      ypos = ypos,
      ...
    )
  )
}


StatSmoothFunc <- ggproto("StatSmooth", Stat,
                          
                          setup_params = function(data, params) {
                            # Figure out what type of smoothing to do: loess for small datasets,
                            # gam with a cubic regression basis for large data
                            # This is based on the size of the _largest_ group.
                            if (identical(params$method, "auto")) {
                              max_group <- max(table(data$group))
                              
                              if (max_group < 1000) {
                                params$method <- "loess"
                              } else {
                                params$method <- "gam"
                                params$formula <- y ~ s(x, bs = "cs")
                              }
                            }
                            if (identical(params$method, "gam")) {
                              params$method <- mgcv::gam
                            }
                            
                            params
                          },
                          
                          compute_group = function(data, scales, method = "auto", formula = y~x,
                                                   se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
                                                   xseq = NULL, level = 0.95, method.args = list(),
                                                   na.rm = FALSE, xpos=NULL, ypos=NULL) {
                            if (length(unique(data$x)) < 2) {
                              # Not enough data to perform fit
                              return(data.frame())
                            }
                            
                            if (is.null(data$weight)) data$weight <- 1
                            
                            if (is.null(xseq)) {
                              if (is.integer(data$x)) {
                                if (fullrange) {
                                  xseq <- scales$x$dimension()
                                } else {
                                  xseq <- sort(unique(data$x))
                                }
                              } else {
                                if (fullrange) {
                                  range <- scales$x$dimension()
                                } else {
                                  range <- range(data$x, na.rm = TRUE)
                                }
                                xseq <- seq(range[1], range[2], length.out = n)
                              }
                            }
                            # Special case span because it's the most commonly used model argument
                            if (identical(method, "loess")) {
                              method.args$span <- span
                            }
                            
                            if (is.character(method)) method <- match.fun(method)
                            
                            base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
                            model <- do.call(method, c(base.args, method.args))
                            
                            m = model
                            eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
                                             list(a = format(coef(m)[1], digits = 3), 
                                                  b = format(coef(m)[2], digits = 3), 
                                                  r2 = format(summary(m)$r.squared, digits = 3)))
                            func_string = as.character(as.expression(eq))
                            
                            if(is.null(xpos)) xpos = min(data$x)*0.9
                            if(is.null(ypos)) ypos = max(data$y)*0.9
                            data.frame(x=xpos, y=ypos, label=func_string)
                            
                          },
                          
                          required_aes = c("x", "y")
)





```

#### V(D)J recombination number from different starting materials bar plot

```{r}

#exclude q1 and q2
all_dfs <- all_dfs[c(5,1,6,3)]

#make summury table
all_stats <- list()
for(f in seq_along(all_dfs)){
  all_stats[[f]] <- table(get(all_dfs[f])$FUNCTIONAL)
}
# names(all_stats) <- all_dfs
names(all_stats) <- c("a_5ug","b_2.5ug","c_1ug", "d_500ng")

stats_table <- plyr::ldply(all_stats, rbind)
colnames(stats_table) <- c("file", "nonfunctional", "functional")
stats_table$total <- stats_table$nonfunctional + stats_table$functional


stats_table_p <- melt(stats_table[c("file", "functional", "nonfunctional")])

ggplot() +
  geom_bar(aes(x = file,y = value, fill = variable),data=stats_table_p, colour="black", stat = "identity") +
  theme_gdocs() + scale_color_gdocs() +
  # theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0,120000), breaks = pretty(seq(0,120000), 10), labels = scales::comma)
# ggsave("/media/chovanec/My_Passport/protocol_paper/histogram_results.pdf", width = 10, height = 10, units="cm")


# 
```

#### V gene usage reproducability

```{r}

five_vs_two_five <- merge(data.frame(table(lane5460_ACAGTG_2_5ug$V_CALL_gene)), 
                          data.frame(table(lane5460_GCCAAT_5ug$V_CALL_gene)), 
                          by="Var1", suffixes = c("_2_5","_5"))
five_vs_one <- merge(data.frame(table(lane5460_TGACCA_1ug$V_CALL_gene)), 
                     data.frame(table(lane5460_GCCAAT_5ug$V_CALL_gene)), 
                     by="Var1", suffixes = c("_1","_5"))
five_vs_five_hund <- merge(data.frame(table(lane5460_CGATGT_500ng$V_CALL_gene)), 
                           data.frame(table(lane5460_GCCAAT_5ug$V_CALL_gene)), 
                           by="Var1", suffixes = c("_500","_5"))
q1_vs_q2 <- merge(data.frame(table(lane5460_CAGATC_Q1$V_CALL_gene)), data.frame(table(lane5460_CTTGTA_Q2$V_CALL_gene)), by="Var1")
one_vs_q2 <- merge(data.frame(table(lane5460_TGACCA_1ug$V_CALL_gene)), data.frame(table(lane5460_CTTGTA_Q2$V_CALL_gene)), by="Var1")
one_vs_q1 <- merge(data.frame(table(lane5460_TGACCA_1ug$V_CALL_gene)), data.frame(table(lane5460_CAGATC_Q1$V_CALL_gene)), by="Var1")

#convert to %
five_vs_five_hund$perc_500 <- round((five_vs_five_hund$Freq_500/sum(five_vs_five_hund$Freq_500))*100, 2)
five_vs_five_hund$perc_5 <- round((five_vs_five_hund$Freq_5/sum(five_vs_five_hund$Freq_5))*100, 2)

five_vs_two_five$perc_2_5 <- round((five_vs_two_five$Freq_2_5/sum(five_vs_two_five$Freq_2_5))*100, 2)
five_vs_two_five$perc_5 <- round((five_vs_two_five$Freq_5/sum(five_vs_two_five$Freq_5))*100, 2)


# pdf("/media/chovanec/My_Passport/protocol_paper/reproducability_2.pdf", width = 3, height = 3)

ggplot(data = five_vs_two_five, aes(x = perc_2_5, y = perc_5)) +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  geom_smooth(method="lm",se=FALSE) +
  geom_point() +
  ylab(label = "5ug") +
  xlab(label = "2.5ug") +
  theme_gdocs() + scale_color_gdocs() +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0))

ggplot(data = five_vs_five_hund, aes(x = perc_500, y = perc_5)) +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  geom_smooth(method="lm",se=FALSE) +
  geom_point() +
  ylab(label = "5ug") +
  xlab(label = "500ng") +
  theme_gdocs() + scale_color_gdocs() +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0))

# dev.off()


```


#### Fidelity assesment


```{r}


library(reshape2)
CAGATC_Q1 <- read_delim("/media/chovanec/My_Passport/protocol_paper/lane5460_CAGATC_Q1_L001_R1_val_1_Deduplicated/lane5460_CAGATC_Q1_L001_R1_val_1_per_umi.tsv", 
                                                       "\t", escape_double = FALSE, trim_ws = TRUE)

CTTGTA_Q2 <- read_delim("/media/chovanec/My_Passport/protocol_paper/lane5460_CTTGTA_Q2_L001_R1_val_1_Deduplicated/lane5460_CTTGTA_Q2_L001_R1_val_1_per_umi.tsv", 
                                                       "\t", escape_double = FALSE, trim_ws = TRUE)

TGACCA_1ug <- read_delim("/media/chovanec/My_Passport/protocol_paper/lane5460_TGACCA_1ug_L001_R1_val_1_Deduplicated/lane5460_TGACCA_1ug_L001_R1_val_1_per_umi.tsv", 
                                                        "\t", escape_double = FALSE, trim_ws = TRUE)


#remove same umi different barcode
CAGATC_Q1 <- CAGATC_Q1[!grepl("_", CAGATC_Q1$Consensus_differences),]
CTTGTA_Q2 <- CTTGTA_Q2[!grepl("_", CTTGTA_Q2$Consensus_differences),]
TGACCA_1ug <- TGACCA_1ug[!grepl("_", TGACCA_1ug$Consensus_differences),]

Q1 <- data.frame(table(unlist(strsplit(CAGATC_Q1$Consensus_differences, ","))))
Q2 <- data.frame(table(unlist(strsplit(CTTGTA_Q2$Consensus_differences, ","))))
PWO <- data.frame(table(unlist(strsplit(TGACCA_1ug$Consensus_differences, ","))))


Q1$Var1 <- as.numeric(as.character(Q1$Var1))
Q2$Var1 <- as.numeric(as.character(Q2$Var1))
PWO$Var1 <- as.numeric(as.character(PWO$Var1))

# normalise by total countcount_data
Q1$norm <- sapply(Q1$Freq, function(x) x/sum(Q1$Freq))
Q2$norm <- sapply(Q2$Freq, function(x) x/sum(Q2$Freq))
PWO$norm <- sapply(PWO$Freq, function(x) x/sum(PWO$Freq))


plot_data <- melt(data.frame(
  Q5=(Q2$Freq[1]/sum(Q2$Freq))*100,
  Q5_vent_exo=(Q1$Freq[1]/sum(Q1$Freq))*100,
  PWO=(PWO$Freq[1]/sum(PWO$Freq))*100))


ggplot(plot_data, aes(x=variable, y=value)) +
  geom_bar(stat = "identity") +
  coord_cartesian(ylim=c(70,90)) +
  xlab(label="Polymerase") + 
  ylab(label="% reads without error") +
  theme_gdocs() +
  theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5))


```

#### How many clonotypes overlap between the datasets

```{r}

#create unique identifier for each clonotype
clonotype_500 <- data.frame(vcdr3j=paste0(lane5460_CGATGT_500ng$V_CALL_gene, '_', lane5460_CGATGT_500ng$CDR3_IGBLAST_NT, '_', lane5460_CGATGT_500ng$J_CALL_gene), 
                            clonotype=lane5460_CGATGT_500ng$clonotype)
clonotype_2.5 <- data.frame(vcdr3j=paste0(lane5460_ACAGTG_2_5ug$V_CALL_gene, '_', lane5460_ACAGTG_2_5ug$CDR3_IGBLAST_NT, '_', lane5460_ACAGTG_2_5ug$J_CALL_gene), 
                            clonotype=lane5460_ACAGTG_2_5ug$clonotype)
clonotype_5 <- data.frame(vcdr3j=paste0(lane5460_GCCAAT_5ug$V_CALL_gene, '_', lane5460_GCCAAT_5ug$CDR3_IGBLAST_NT, '_', lane5460_GCCAAT_5ug$J_CALL_gene), 
                          clonotype=lane5460_GCCAAT_5ug$clonotype)

clonotype_500 <- clonotype_500[!duplicated(clonotype_500$vcdr3j),]
clonotype_2.5 <- clonotype_2.5[!duplicated(clonotype_2.5$vcdr3j),]
clonotype_5 <- clonotype_5[!duplicated(clonotype_5$vcdr3j),]

clonotype_500 <- clonotype_500[!duplicated(clonotype_500$clonotype),]
clonotype_2.5 <- clonotype_2.5[!duplicated(clonotype_2.5$clonotype),]
clonotype_5 <- clonotype_5[!duplicated(clonotype_5$clonotype),]

intersect_2.5_5 <- intersect(clonotype_2.5$vcdr3j, clonotype_5$vcdr3j)
intersect_500_5 <- intersect(clonotype_500$vcdr3j, clonotype_5$vcdr3j)

clono_5_int_500 <- clonotype_5[clonotype_5$vcdr3j %in% intersect_500_5,]
clono_2.5_int_5 <- clonotype_2.5[clonotype_2.5$vcdr3j %in% intersect_2.5_5,]


#make venn diagram

c500_c5 <- length(unique(clono_5_int_500$clonotype))
c2.5_5 <- length(unique(clono_2.5_int_5$clonotype))

c500 <- length(clonotype_500$vcdr3j[(!duplicated(clonotype_500$clonotype))])
c2.5 <- length(clonotype_2.5$vcdr3j[!duplicated(clonotype_2.5$clonotype)])
c5 <- length(clonotype_5$vcdr3j[!duplicated(clonotype_5$clonotype)])

print(paste("c500&c5:", c500_c5, sep=" "))
print(paste("c2.5&5:", c2.5_5, sep=" "))
print(paste("c500:", c500, sep=" "))
print(paste("c2.5:", c2.5, sep=" "))
print(paste("c5:", c5, sep=" "))

#plot venn

library(eulerr)

# pdf("/media/chovanec/My_Passport/protocol_paper/venns.pdf")

fit <- euler(c(c5=c5-c500_c5, c500=c500-c500_c5, "c5&c500"=c500_c5))
plot(fit, labels = c("5ug", "500ng"), main = "Clonotype overlap")
fit <- euler(c(c5=c5-c2.5_5, c2.5=c2.5-c2.5_5, "c5&c2.5"=c2.5_5))
plot(fit, labels = c("5ug", "2.5ug"), main = "Clonotype overlap")

# dev.off()


```




#### Capture efficiency


```{r}

capture_efficiency <- function(starting_ng, data_set){
  noc <- (starting_ng*6.022e23)/(500*1e9*650)
  nobp <- noc*500
  
  mouse_genome <- 2.8e9 #2 copies per genome
  total_copies <- (round(nobp/mouse_genome))
  
  #spleen VDJ 3/4 DJ 1/4 (75% to 25%)
  vdj_copies <- total_copies*3/4
  
  return((nrow(data_set)/vdj_copies)*100)
  
  
}

cap_eff <- c(capture_efficiency(500, lane5460_CGATGT_500ng),
capture_efficiency(1000, lane5460_TGACCA_1ug),
capture_efficiency(2500, lane5460_ACAGTG_2_5ug),
capture_efficiency(5000, lane5460_GCCAAT_5ug),
capture_efficiency(1000, lane5460_CAGATC_Q1),
capture_efficiency(1000, lane5460_CTTGTA_Q2))


plot_data_ef <- data.frame(capture_eff=cap_eff)
plot_ef <- melt(plot_data_ef)
plot_ef$id <- c("a_500ng", "b_1ug", "c_2.5ug", "d_5ug", "e_Q1", "f_Q2")
plot_ef$group <- c("main", "main", "main", "main", "Q1", "Q2")


ggplot(data=plot_ef[1:6,], aes(x = variable, y= value, fill=id))+
  geom_bar(stat = "identity", position = position_dodge(width=1), colour="black") +
  ylab(label = "% capture efficiency") +
  xlab(label = "") +
  theme_gdocs() +
  scale_y_continuous(expand = c(0, 0), limits = c(0,10), breaks = pretty(seq(0,10), 8)) +
  facet_grid(~id)
  
# ggsave("/media/chovanec/My_Passport/protocol_paper/capture_efficiency_one.pdf", width = 9, height = 8, units="cm")


```


#### Data assembled into clonotypes using alt_assemble_clones.py. Due to high number of duplicates, using clonotypes gives a fairer representation.

```{r}
################################################################################
#Alt data clonotype assembled
################################################################################

splB_2ug_rep123 <- suppressWarnings(suppressMessages(read_delim("/media/chovanec/My_Passport/alt_data/GSM2183875_splB_2ug_repeat123_BL6.pass.tab", 
                                                     "\t", escape_double = FALSE, trim_ws = TRUE)))

splB_500ng_rep123 <- suppressWarnings(suppressMessages(read_delim("/media/chovanec/My_Passport/alt_data/splB_500ng_repeat123_BL6.pass.tab", 
                                            "\t", escape_double = FALSE, trim_ws = TRUE)))

splB_100ng_rep123 <- suppressWarnings(suppressMessages(read_delim("/media/chovanec/My_Passport/alt_data/splB_100ng_repeat123_BL6.pass.tab", 
                                "\t", escape_double = FALSE, trim_ws = TRUE)))


splB_2ug_rep1 <- suppressWarnings(suppressMessages(read_delim("/media/chovanec/My_Passport/alt_data/splB_2ug_repeat1_BL6.pass.tab", 
                              "\t", escape_double = FALSE, trim_ws = TRUE)))

splB_500ng_rep1 <- suppressWarnings(suppressMessages(read_delim("/media/chovanec/My_Passport/alt_data/splB_500ng_repeat1_BL6.pass.tab", 
                                "\t", escape_double = FALSE, trim_ws = TRUE)))

splB_100ng_rep1 <- suppressWarnings(suppressMessages(read_delim("/media/chovanec/My_Passport/alt_data/splB_100ng_repeat1_BL6.pass.tab", 
                                "\t", escape_double = FALSE, trim_ws = TRUE)))


```

HTGTS-Rep-Seq http://dx.doi.org/10.1073/pnas.1608649113

#### Python script to assign clonotype based on VJ annotation and CDR3 nucleotides, allowing 1 nt mismatch in the CDR3 (same as in assemble_clones.py)

```{python}

import pandas as pd
from collections import defaultdict
from babrahamlinkon import umi_correction
import pyximport
from babrahamlinkon._dedup_umi import edit_distance

def make_bundle(pd_data_frame, only_v=False):
    '''Make dictionary of V-CRD3-J (bundle)
    '''
    clonotype_dict = defaultdict(lambda: defaultdict(dict))

    for line in pd_data_frame.index:
        if only_v:
            v_j = pd_data_frame['V_CALL'][line]
        else:
            v_j = pd_data_frame['Top V gene match'][line] + '_' + pd_data_frame['Top J gene match'][line]

        #use IgBlast CDR3
        cdr3 = pd_data_frame['CDR3_nucl'][line]

        #seperate group based on sequence length as well as V and J
        v_j_len = v_j + '_' + str(len(cdr3))

        try:
            clonotype_dict[v_j_len][cdr3]['qname'].append(pd_data_frame['Qname'][line])
            clonotype_dict[v_j_len][cdr3]['count'] += 1
        except KeyError:
            clonotype_dict[v_j_len][cdr3]['qname'] = [pd_data_frame['Qname'][line]]
            clonotype_dict[v_j_len][cdr3]['count'] = 1

    return clonotype_dict

#use all as very few sequences
files_100ng = ['/media/chovanec/My_Passport/alt_data/GSM2183872_splB_100ng_repeat1_BL6.pass.xls',
'/media/chovanec/My_Passport/alt_data/GSM2183873_splB_100ng_repeat2_BL6.pass.xls',
'/media/chovanec/My_Passport/alt_data/GSM2183874_splB_100ng_repeat3_BL6.pass.xls']

files_500ng = ['/media/chovanec/My_Passport/alt_data/GSM2183878_splB_500ng_repeat1_BL6.pass.xls']

files_2ug = ['/media/chovanec/My_Passport/alt_data/GSM2183875_splB_2ug_repeat1_BL6.pass.xls']


def read_data(tab_file):

    igblast_out = pd.DataFrame()
    df_list = []
    for f in tab_file:
        df = pd.read_table(f, header=0)
        df_list.append(df)
    igblast_out = pd.concat(df_list)
    igblast_out.reset_index(drop=True, inplace=True)

    return igblast_out



def adj_list_adjacency(umis, counts, threshold=1):
    ''' identify all umis within the hamming distance threshold'''

    adj_list = defaultdict(list)
    for i,umi in enumerate(umis):
        a1 = adj_list[umi]
        for j in range(i+1,len(umis)):
            umi2 = umis[j] #dict_keys object doesn't support indexing

            if len(umi) == len(umi2):
                if edit_distance(umi.encode('utf-8'), umi2.encode('utf-8')) <= threshold:
                    adj_list[umi].append(umi2)

    return adj_list


def assemble_colonotype(pd_data_frame, bundles, threshold):
    '''
    '''

    pd_data_frame['clonotype'] = ''

    bundle_count = 0
    for bundle in bundles.values():
        umis = bundle.keys()

        counts = {umi: bundle[umi]['count'] for umi in umis}
        adj_list = adj_list_adjacency(list(umis), counts, threshold)

        clusters = umi_correction.get_connected_components_adjacency(umis, adj_list, counts)

        #Assign clonotypes
        cluster_count = 0
        for cluster in clusters:
            for cdr3 in cluster:
                #write into original pandas table
                for qname in bundle[cdr3]['qname']:
                    row_loc = pd_data_frame.Qname[pd_data_frame.Qname == qname].index.tolist()[0]
                    pd_data_frame.set_value(row_loc, 'clonotype', str(bundle_count) + '_' + str(cluster_count))
                    
            cluster_count += 1
        bundle_count += 1

    return pd_data_frame

def write_out(pd_data_frame, out):
    pd_data_frame.to_csv(out, sep='\t')


data_100ng = read_data(tab_file)
bundles_100ng = make_bundle(data_100ng)
len(bundles)
out_data_100ng = assemble_colonotype(data_100ng, bundles_100ng, 1)
write_out(out_data_100ng, '/media/chovanec/My_Passport/alt_data/splB_100ng_repeat1_BL6.pass.tab')


data_500ng = read_data(files_500ng)
bundles_500ng = make_bundle(data_500ng)
len(bundles_500ng)
out_data_500ng = assemble_colonotype(data_500ng, bundles_500ng, 1)

write_out(out_data_500ng, '/media/chovanec/My_Passport/alt_data/splB_500ng_repeat1_BL6.pass.tab')


data_2ug = read_data(files_2ug)
bundles_2ug = make_bundle(data_2ug)
len(bundles_2ug)
out_data_2ug = assemble_colonotype(data_2ug, bundles_2ug, 1)
write_out(out_data_2ug, '/media/chovanec/My_Passport/alt_data/splB_2ug_repeat1_BL6.pass.tab')

```


#### HTGTS-Rep-Seq clonotype analysis

```{r}

splB_100ng_rep1_dedup <- splB_100ng_rep1[!duplicated(splB_100ng_rep1$clonotype),]
splB_500ng_rep1_dedup <- splB_500ng_rep1[!duplicated(splB_500ng_rep1$clonotype),]
splB_2ug_rep1_dedup <- splB_2ug_rep1[!duplicated(splB_2ug_rep1$clonotype),]


alt_dfs <- c("splB_100ng_rep1_dedup", "splB_500ng_rep1_dedup", "splB_2ug_rep1_dedup")

#make summury table
alt_stats <- list()
for(f in seq_along(alt_dfs)){
  alt_stats[[f]] <- table(get(alt_dfs[f])$`V-J frame`)
}
# names(all_stats) <- all_dfs
names(alt_stats) <- c("c_100ng","b_500ng","a_2ug")

alt_stats_table <- plyr::ldply(alt_stats, rbind)
alt_stats_table$nonfunctional <- alt_stats_table$`In-frame with stop codon` + alt_stats_table$`Out-of-frame`
colnames(alt_stats_table) <- c("file", "functional", "In-frame with stop codon", "Out-of-frame", "nonfunctional")
alt_stats_table$total <- alt_stats_table$nonfunctional + alt_stats_table$functional


alt_stats_table_p <- melt(alt_stats_table[c("file", "functional", "nonfunctional")])

ggplot() +
  geom_bar(aes(x = file,y = value, fill = variable),data=alt_stats_table_p, colour="black", stat = "identity") +
  theme_gdocs() + scale_color_gdocs() +
  theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0,12000), breaks = pretty(seq(0,12000), 5), labels = scales::comma)
# ggsave("/media/chovanec/My_Passport/protocol_paper/histogram_results_alt.pdf", width = 9, height = 10, units="cm")



clono_500 <- lane5460_CGATGT_500ng[!duplicated(lane5460_CGATGT_500ng$clonotype),]
clono_1 <- lane5460_TGACCA_1ug[!duplicated(lane5460_TGACCA_1ug$clonotype),]
clono_2.5 <- lane5460_ACAGTG_2_5ug[!duplicated(lane5460_ACAGTG_2_5ug$clonotype),]
clono_5 <- lane5460_GCCAAT_5ug[!duplicated(lane5460_GCCAAT_5ug$clonotype),]


all_dfs_clono <- c(clono_500, clono_1, clono_2.5, clono_5)

#make summury table
all_stats_clono <- list()
for(f in seq_along(all_dfs)){
  all_stats[[f]] <- table(get(all_dfs[f])$FUNCTIONAL)
}
# names(all_stats) <- all_dfs
names(all_stats) <- c("a_5ug","b_2.5ug","c_1ug", "d_500ng")

stats_table <- plyr::ldply(all_stats, rbind)
colnames(stats_table) <- c("file", "nonfunctional", "functional")
stats_table$total <- stats_table$nonfunctional + stats_table$functional


stats_table_p <- melt(stats_table[c("file", "functional", "nonfunctional")])

ggplot() +
  geom_bar(aes(x = file,y = value, fill = variable),data=stats_table_p, colour="black", stat = "identity") +
  theme_gdocs() + scale_color_gdocs() +
  theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0,120000), breaks = pretty(seq(0,120000), 10), labels = scales::comma)
# ggsave("/media/chovanec/My_Passport/protocol_paper/histogram_results_clono.pdf", width = 10, height = 10, units="cm")


alt_vs_our_500 <- merge(data.frame(table(clono_500$V_CALL_gene)), data.frame(table(splB_500ng_rep1_dedup$Gene_name)), by="Var1")
alt_vs_our_2 <- merge(data.frame(table(clono_2.5$V_CALL_gene)), data.frame(table(splB_2ug_rep1_dedup$Gene_name)), by="Var1")

# pdf("/media/chovanec/My_Passport/protocol_paper/alt_compared_ours.pdf", width = 3, height = 3)
ggplot(data = alt_vs_our_500, aes(x = Freq.x, y = Freq.y)) +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  geom_smooth(method="lm",se=FALSE) +
  geom_point() +
  ylab(label = "500ng Alt") +
  xlab(label = "500ng Corcoran") +
  theme_gdocs() + scale_color_gdocs() +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0))

ggplot(data = alt_vs_our_2, aes(x = Freq.x, y = Freq.y)) +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  geom_smooth(method="lm",se=FALSE) +
  geom_point() +
  ylab(label = "2ug Alt") +
  xlab(label = "2.5ug Corcoran") +
  theme_gdocs() + scale_color_gdocs() +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0))

# dev.off()
```


#### Get V gene order along the IGH


```{r}
ensembl = useEnsembl(biomart="ensembl", dataset="mmusculus_gene_ensembl")

chr12_genes <- getBM(attributes=c('ensembl_gene_id', 'description', 'external_gene_name', 'chromosome_name','start_position','end_position', 'gene_biotype'), 
                     filters ='chromosome_name', values ="12", mart = ensembl)

igh_genes <- chr12_genes[grep("Igh", chr12_genes$external_gene_name),]
igh_genes <- igh_genes[order(igh_genes$start_position), ]
igh_gene_name <- unique(toupper(igh_genes$external_gene_name[33:length(igh_genes$external_gene_name)]))
igh_gene_functional <- unique(toupper(igh_genes$external_gene_name[igh_genes$gene_biotype == "IG_V_gene"]))


```

http://dx.doi.org/10.1073/pnas.1403278111 (NCBI BioProject number: PRJNA248676)
Data from Kaplinsky et al. were downloaded and converted from fastq to fasta. The fasta was subsequentyl run through assemble_clones.py to annotate sequences.

```{bash}
#need to have BabrahamlinkON installed

assemble_clones.py umi -fa SRR1301994.fasta \
--full_name --threads 8 --species mmu --plot --v_cutoff 100 --skip_assembly

assemble_clones.py umi -fa SRR1301998.fasta \
--full_name --threads 8 --species mmu --plot --v_cutoff 100 --skip_assembly

assemble_clones.py umi -fa SRR1302000.fasta \
--full_name --threads 8 --species mmu --plot --v_cutoff 100 --skip_assembly

```

#### Kaplinsky V gene usage compared to ours

```{r}

SRR1301994_a_cl <- suppressWarnings(suppressMessages(read_delim("/media/chovanec/My_Passport/protocol_paper/kaplinsky_data/SRR1301994_annotated_clones.tab", 
                                          "\t", escape_double = FALSE, trim_ws = TRUE, progress=FALSE)))

SRR1301998_a_cl <- suppressWarnings(suppressMessages(read_delim("/media/chovanec/My_Passport/protocol_paper/kaplinsky_data/SRR1301998_annotated_clones.tab", 
                                          "\t", escape_double = FALSE, trim_ws = TRUE, progress=FALSE)))

SRR1302000_a_cl <- suppressWarnings(suppressMessages(read_delim("/media/chovanec/My_Passport/protocol_paper/kaplinsky_data/SRR1302000_annotated_clones.tab", 
                                          "\t", escape_double = FALSE, trim_ws = TRUE, progress=FALSE)))


k_dfs <- c("SRR1301994_a_cl", "SRR1301998_a_cl", "SRR1302000_a_cl")


filter_score <- function(df){
  df_n <- df[df$V_SCORE >= 100,]
  df_n <- df_n[!is.na(df_n$X1),]
  #New column with true V_call and V_score
  df_n$V_CALL_first <- sapply(strsplit(df_n$V_CALL, ","), "[[", 1)
  df_n$V_CALL_gene <- sapply(strsplit(df_n$V_CALL_first, "\\*"), "[[", 1)
  df_n$J_CALL_first <- sapply(strsplit(df_n$J_CALL, ","), "[[", 1)
  df_n$J_CALL_gene <- sapply(strsplit(df_n$J_CALL_first, "\\*"), "[[", 1)
  return(df_n)
}


#filter data for low v gene scores
for(i in seq_along(k_dfs)){
  assign(k_dfs[i], filter_score(get(k_dfs[i])))
}

# try remove duplicates

SRR1301994_a_cl <- SRR1301994_a_cl[!duplicated(SRR1301994_a_cl$SEQUENCE_INPUT),]
SRR1301998_a_cl <- SRR1301998_a_cl[!duplicated(SRR1301994_a_cl$SEQUENCE_INPUT),]
SRR1302000_a_cl <- SRR1302000_a_cl[!duplicated(SRR1301994_a_cl$SEQUENCE_INPUT),]





rep_vs_rep <- merge(data.frame(table(SRR1301994_a_cl$V_CALL_gene)), data.frame(table(SRR1301998_a_cl$V_CALL_gene)), by="Var1")
five_vs_rep <- merge(data.frame(table(lane5460_GCCAAT_5ug$V_CALL_gene)), data.frame(table(SRR1301994_a_cl$V_CALL_gene)), by="Var1")
five_vs_rep2 <- merge(data.frame(table(lane5460_GCCAAT_5ug$V_CALL_gene)), data.frame(table(SRR1301998_a_cl$V_CALL_gene)), by="Var1")
five_vs_rep3 <- merge(data.frame(table(lane5460_GCCAAT_5ug$V_CALL_gene)), data.frame(table(SRR1302000_a_cl$V_CALL_gene)), by="Var1")

five_vs_rep_func <- five_vs_rep[five_vs_rep$Var1 %in% igh_gene_functional,]

# pdf("/media/chovanec/My_Passport/protocol_paper/kaplinsky_comparison.pdf", width = 3, height = 3)

ggplot(data = rep_vs_rep, aes(x = Freq.x, y = Freq.y)) +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  geom_smooth(method="lm",se=FALSE) +
  geom_point() +
  ylab(label = "VJ primer rep1") +
  xlab(label = "VJ primer rep2") +
  theme_gdocs() + scale_color_gdocs() +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0))

ggplot(data = five_vs_rep, aes(x = Freq.x, y = Freq.y)) +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  geom_smooth(method="lm",se=FALSE) +
  geom_point() +
  ylab(label = "VJ primer rep1") +
  xlab(label = "5ug") +
  theme_gdocs() + scale_color_gdocs() +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0))


ggplot(data = five_vs_rep2, aes(x = Freq.x, y = Freq.y)) +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  geom_smooth(method="lm",se=FALSE) +
  geom_point() +
  ylab(label = "VJ primer rep2") +
  xlab(label = "5ug") +
  theme_gdocs() + scale_color_gdocs() +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0))

ggplot(data = five_vs_rep3, aes(x = Freq.x, y = Freq.y)) +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  geom_smooth(method="lm",se=FALSE) +
  geom_point() +
  ylab(label = "VJ primer rep3") +
  xlab(label = "5ug") +
  theme_gdocs() + scale_color_gdocs() +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0))

# ggplot(data = five_vs_rep_func, aes(x = Freq.x, y = Freq.y)) +
#   stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
#   geom_smooth(method="lm",se=FALSE) +
#   geom_point() +
#   ylab(label = "VJ primer rep3") +
#   xlab(label = "5ug") +
#   theme_gdocs() + scale_color_gdocs() +
#   scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0))

# dev.off()

```

#### V gene usage comparison across the locus

```{r}

#IGHV1-62-2 and 1-71 are the same sequence

freq_v_gene_usage_igb <- function(assembled_clones, sample_name, type, functionality){
  
  #seperate into functional non-functional
  functional <- assembled_clones[assembled_clones$FUNCTIONAL,]
  non_functional <- assembled_clones[!assembled_clones$FUNCTIONAL,]
  
  print(paste("# functional:", nrow(functional), "; # non functional:", nrow(non_functional), collapse=" "))
  #subset data
  
  functional_vdj <- data.frame(functional$V_CALL)
  non_functional_vdj <- data.frame(non_functional$V_CALL)
  
  #Get v gene frequencies of functional
  freqs_v <- as.data.frame(table(as.matrix(functional_vdj$functional.V_CALL)))
  
  #remove allele
  freqs_v$Var1 <- sapply(strsplit(as.character(freqs_v$Var1), "\\*"), "[[", 1)
  ord_freqs_v <- freqs_v[match(igh_gene_name, freqs_v$Var1),]
  
  ord_freqs_v$Var1 <- igh_gene_name
  ord_freqs_v$Freq[is.na(ord_freqs_v$Freq)] = 0
  
  ord_freqs_v$func <- rep("functional", nrow(ord_freqs_v))
  
  #get v gene frequencies of non-functional
  non_freqs_v <- as.data.frame(table(as.matrix(non_functional_vdj$non_functional.V_CALL)))
  
  #remove allele
  non_freqs_v$Var1 <- sapply(strsplit(as.character(non_freqs_v$Var1), "\\*"), "[[", 1)
  non_ord_freqs_v <- non_freqs_v[match(igh_gene_name, non_freqs_v$Var1),]
  
  non_ord_freqs_v$Var1 <- igh_gene_name
  non_ord_freqs_v$Freq[is.na(non_ord_freqs_v$Freq)] = 0
  
  # non_func_freq <- non_ord_freqs_v[-c(1:40),]
  non_ord_freqs_v$func <- rep("non-functional", nrow(non_ord_freqs_v))
  
  #combined functional and non-functional
  all_freq <- rbind(ord_freqs_v, non_ord_freqs_v)
  
  #Need to specify levels for order to be maintained in ggplot
  all_freq$Var1 <- factor(all_freq$Var1, levels = igh_gene_name)
  
  all_freq$Freq <- (all_freq$Freq/nrow(functional_vdj))*100
  all_freq$sample <- rep(sample_name, nrow(all_freq))
  
  all_freq$type <- rep(type, nrow(all_freq))
  
  if(functionality == "functional"){
    return(all_freq[all_freq$func == "functional",])
  }else if(functionality == "non-functional"){
    return(all_freq[all_freq$func == "non-functional",])
  }
  
}

SRR1301994_a_cl_v_gene <- freq_v_gene_usage_igb(SRR1301994_a_cl, "SRR1301994_a_cl", "SpleenB", "functional")

lane5460_GCCAAT_5ug_v_gene <- freq_v_gene_usage_igb(lane5460_GCCAAT_5ug, "lane5460_GCCAAT_5ug", "SpleenB", "functional")

splB_2ug_rep123_dedup <- splB_2ug_rep123[!duplicated(splB_2ug_rep123$clonotype),]

splB_2ug_rep123$FUNCTIONAL <- splB_2ug_rep123$`V-J frame` == "In-frame"
#need to rename some columns
names(splB_2ug_rep123)[38] <- "V_CALL"

splB_2ug_rep123_v_gene <- freq_v_gene_usage_igb(splB_2ug_rep123, "splB_2ug_rep123", "SpleenB", "functional")

#VJ primers
freqs_df <- rbind(lane5460_GCCAAT_5ug_v_gene, SRR1301994_a_cl_v_gene)
#remove 0 values
freqs_df_nz = freqs_df[freqs_df$Freq != 0, ]

#Need to specify levels for order to be maintained in ggplot
freqs_df_nz$Var1 <- factor(freqs_df_nz$Var1, levels = igh_gene_name)



# pdf("/run/user/1000/gvfs/smb-share:server=filer1b,share=aecgroup/for_Dan/figures/v_gene_box_plots_RNA_igblast.pdf",width = 25, height = 8)
ggplot(aes(y = Freq,x = Var1,fill = sample),data=freqs_df_nz) +
  geom_bar(stat = "identity", position = "dodge", colour="black") +
  theme_gdocs() +
  theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5, size=7)) +
  xlab(label = 'V genes') +
  ylab(label = '% of functional repertoire') +
  scale_y_continuous(expand = c(0, 0)) +
  theme(legend.position="bottom")


#HTGTS-Rep-seq
freqs_df <- rbind(lane5460_GCCAAT_5ug_v_gene, splB_2ug_rep123_v_gene)
#remove 0 values
freqs_df_nz = freqs_df[freqs_df$Freq != 0, ]

#Need to specify levels for order to be maintained in ggplot
freqs_df_nz$Var1 <- factor(freqs_df_nz$Var1, levels = igh_gene_name)

ggplot(aes(y = Freq,x = Var1,fill = sample),data=freqs_df_nz) +
  geom_bar(stat = "identity", position = "dodge", colour="black") +
  theme_gdocs() +
  theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5, size=7)) +
  xlab(label = 'V genes') +
  ylab(label = '% of functional repertoire') +
  scale_y_continuous(expand = c(0, 0)) +
  theme(legend.position="bottom")

```

#### Sonication bias 

```{python}
import pandas as pd
import numpy as np
from collections import defaultdict, Counter

table = '/media/chovanec/My_Passport/protocol_paper/lane5460_GCCAAT_5ug_L001_R1_val_1_dedup_assembled_clones.tab'


df = pd.read_table(table, header=0)

df['SEQUENCE_VDJ'][4]
df['V_SEQ_START'][4]
df['V_SEQ_LENGTH'][4]

df['V_GERM_START_IMGT'][4]
df['V_GERM_LENGTH_IMGT'][4]

df['SEQUENCE_IMGT'][4][0:316]
df['V_CALL'][0].split('*')[0]
#seperate out by V gene
v_seqs = defaultdict(list)
# v_seqs = []
for i in range(len(df.index)):
    start = df['V_GERM_START_IMGT'][i]-1
    end = start + df['V_GERM_LENGTH_IMGT'][i]
    v_seq = df['SEQUENCE_IMGT'][i][start:end]
    assert df['V_GERM_LENGTH_IMGT'][i] == len(v_seq), 'Length does not match'
    v_call = df['V_CALL'][i].split('*')[0]
    v_seqs[v_call].append(v_seq)

len(v_seqs.keys())

v_hist = defaultdict()
for key, value in v_seqs.items():
    hist = defaultdict(int)
    for seq in value: #seq for a v gene
        for pos in range(len(seq)):
            if seq[pos] != '.':
                hist[pos] += 1
    v_hist[key] = hist

hist_data = pd.DataFrame.from_dict(v_hist)
hist_data.fillna(0).to_csv('/media/chovanec/My_Passport/protocol_paper/sonication_hist.tab', sep='\t')

```

#### Plot sonication bias 

```{r}

sonication_hist <- read_delim("/media/chovanec/My_Passport/protocol_paper/sonication_hist.tab", 
                              "\t", escape_double = FALSE, trim_ws = TRUE)




sonication_hist$mean <- apply(sonication_hist[,-1],1, mean)
sonication_hist$X1 <- order(sonication_hist$X1, decreasing = TRUE)

ggplot(data = sonication_hist, aes(x = X1, y = mean)) + 
  geom_line() +
  theme_gdocs() + 
  scale_y_continuous(expand = c(0, 0), limits = c(0,750)) +
  scale_x_continuous(expand = c(0, 0), limits = c(0,315))

```